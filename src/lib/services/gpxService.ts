import type { ItinerarySummaryJSON } from "../../types";
import { assertValidGpx } from "./gpxValidator";

/**
 * GPX Service
 * Generates GPX 1.1 XML files from itinerary data
 */

/**
 * Generates a GPX 1.1 XML string from an itinerary
 *
 * Note: This is a simplified GPX generation for MVP.
 * Since the itinerary doesn't contain actual GPS coordinates,
 * we generate waypoints with placeholder coordinates based on segment names.
 *
 * In production, this would:
 * - Use actual GPS coordinates from route planning
 * - Include elevation data
 * - Add track points between waypoints
 * - Include proper route metadata
 *
 * @param itinerary The itinerary summary to convert to GPX
 * @param itineraryId The ID of the itinerary (used in metadata)
 * @returns GPX 1.1 XML string
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function generateGPX(itinerary: ItinerarySummaryJSON, _itineraryId?: string): string {
  const now = new Date().toISOString();

  // Validate itinerary has required fields
  if (!itinerary || !itinerary.days || !Array.isArray(itinerary.days)) {
    throw new Error("Invalid itinerary: missing days array");
  }

  // Extract waypoints from segments with GPS coordinates
  // Generate intermediate points for better route guidance
  const waypoints: {
    name: string;
    description: string;
    lat: number;
    lon: number;
    index: number;
    type: "start" | "intermediate" | "end";
  }[] = [];
  let waypointIndex = 0;

  itinerary.days.forEach((day) => {
    if (day.segments && Array.isArray(day.segments)) {
      day.segments.forEach((segment, segmentIdx) => {
        // Use start coordinates for the waypoint
        // If no coordinates provided, use placeholder
        const startLat = segment.start_lat ?? 45.0 + waypointIndex * 0.1;
        const startLon = segment.start_lon ?? -93.0 + waypointIndex * 0.1;
        const endLat = segment.end_lat ?? 45.0 + (waypointIndex + 1) * 0.1;
        const endLon = segment.end_lon ?? -93.0 + (waypointIndex + 1) * 0.1;

        // Add start point
        waypoints.push({
          name: segment.name || "Unnamed waypoint",
          description: segment.description || "",
          lat: startLat,
          lon: startLon,
          index: waypointIndex++,
          type: "start",
        });

        // Generate intermediate points along the segment
        // More points for longer segments (based on distance)
        const distance = segment.distance_km || 0;
        const numIntermediatePoints = calculateIntermediatePoints(distance);

        if (numIntermediatePoints > 0) {
          for (let i = 1; i <= numIntermediatePoints; i++) {
            const ratio = i / (numIntermediatePoints + 1);
            const intermediateLat = startLat + (endLat - startLat) * ratio;
            const intermediateLon = startLon + (endLon - startLon) * ratio;

            waypoints.push({
              name: `${segment.name} - Point ${i}`,
              description: `Intermediate waypoint along ${segment.name}`,
              lat: intermediateLat,
              lon: intermediateLon,
              index: waypointIndex++,
              type: "intermediate",
            });
          }
        }

        // Add end point (except for last segment where we'll add it separately)
        const isLastSegment = day.segments ? segmentIdx === day.segments.length - 1 : true;
        if (!isLastSegment) {
          waypoints.push({
            name: `${segment.name} - End`,
            description: `End of ${segment.name}`,
            lat: endLat,
            lon: endLon,
            index: waypointIndex++,
            type: "end",
          });
        }
      });

      // Add the end point of the last segment as final waypoint for the day
      const lastSegment = day.segments[day.segments.length - 1];
      if (lastSegment) {
        const endLat = lastSegment.end_lat ?? 45.0 + waypointIndex * 0.1;
        const endLon = lastSegment.end_lon ?? -93.0 + waypointIndex * 0.1;

        waypoints.push({
          name: `End of Day ${day.day}`,
          description: "Day endpoint",
          lat: endLat,
          lon: endLon,
          index: waypointIndex++,
          type: "end",
        });
      }
    }
  });

  // Generate GPX XML
  const title = itinerary.title || "Untitled Itinerary";
  const totalDistance = itinerary.total_distance_km || 0;
  const totalDuration = itinerary.total_duration_h || 0;

  const gpxXml = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" 
     creator="VibeRide - https://viberide.com" 
     xmlns="http://www.topografix.com/GPX/1/1"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
  <metadata>
    <name>${escapeXml(title)}</name>
    <desc>Generated by VibeRide - Motorcycle trip itinerary</desc>
    <author>
      <name>VibeRide</name>
      <link href="https://viberide.com">
        <text>VibeRide</text>
      </link>
    </author>
    <time>${now}</time>
    <keywords>motorcycle,trip,itinerary,route</keywords>
  </metadata>
${generateWaypoints(waypoints)}
  <rte>
    <name>${escapeXml(title)}</name>
    <desc>Total distance: ${totalDistance.toFixed(1)} km, Duration: ${totalDuration.toFixed(1)} hours</desc>
${generateRoutePoints(waypoints)}
  </rte>
</gpx>`;

  // Validate the generated GPX before returning
  assertValidGpx(gpxXml);

  return gpxXml;
}

/**
 * Calculate number of intermediate points based on segment distance
 * More points for longer segments to ensure proper road guidance
 *
 * @param distanceKm Distance of the segment in kilometers
 * @returns Number of intermediate points to generate
 */
function calculateIntermediatePoints(distanceKm: number): number {
  if (distanceKm < 20) return 1; // Short segments: 1 intermediate point
  if (distanceKm < 50) return 2; // Medium segments: 2 intermediate points
  if (distanceKm < 100) return 3; // Long segments: 3 intermediate points
  return Math.min(5, Math.floor(distanceKm / 30)); // Very long: up to 5 points
}

/**
 * Generates waypoint XML elements
 * Uses actual GPS coordinates from the itinerary
 * Only includes start and end points as waypoints (not intermediate)
 */
function generateWaypoints(
  waypoints: { name: string; description: string; lat: number; lon: number; index: number; type: string }[]
): string {
  return waypoints
    .filter((wp) => wp.type === "start" || wp.type === "end")
    .map((wp) => {
      return `  <wpt lat="${wp.lat.toFixed(6)}" lon="${wp.lon.toFixed(6)}">
    <name>${escapeXml(wp.name)}</name>
    <desc>${escapeXml(wp.description)}</desc>
    <type>waypoint</type>
  </wpt>`;
    })
    .join("\n");
}

/**
 * Generates route point XML elements
 * Includes all points (start, intermediate, and end) for detailed routing
 */
function generateRoutePoints(
  waypoints: { name: string; description: string; lat: number; lon: number; index: number; type: string }[]
): string {
  return waypoints
    .map((wp) => {
      return `    <rtept lat="${wp.lat.toFixed(6)}" lon="${wp.lon.toFixed(6)}">
      <name>${escapeXml(wp.name)}</name>
      <desc>${escapeXml(wp.description)}</desc>
    </rtept>`;
    })
    .join("\n");
}

/**
 * Escapes special XML characters
 * Handles undefined/null values safely
 */
function escapeXml(text: string | undefined | null): string {
  if (!text) {
    return "";
  }
  return String(text)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}
